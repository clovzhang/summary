## 面试题
## new的实现

### new实现过程

1. 创建一个新的空对象
2. 给新对象构造原型链，内部属性[[Prototype]]属性赋值，指向构造函数的原型
3. 执行构造函数，构造函数的this指向新对象
4. 如果构造函数没有返回其他对象，那么返回这个this,即新对象，否则返回构造函数中的返回对象

### new实现代码

```
function _new () {
    let target = {};
    let {constructor,...args} = [...arguments];
    target.__proto__= constructor.prototype;
    let res = constructor.call(target,args)
    if((typeof res) === 'object' || (typeof res) === 'function'){
        return res
    } else {
        return target
    }
}
```


## promise
1. promise缺点

	* 无法取消promise，一旦新建它就会立即执行，无法中途取消。
	* 如果不设置毁掉函数，Promise内部跑出的错误，不会反应到外部
	* 处于pending状态时，无法得知目前进展到哪一个阶段，刚刚开始还是即将完成

2. 参考

	* [剖析Promise内部结构，一步一步实现一个完整的、能通过所有Test case的Promise类](https://github.com/xieranmaya/blog/issues/3)

## react diff
1. 优点： 作为virtual dom的加速器，优化页面渲染，提高性能

2. react diff 策略

	1. Dom节点跨层级移动特别少，可以忽略不计。
	2. 不同类的两个组件会生成相似的树形结构，相同类的组件树形结构相同
	3. 同一层级相同父元素的子节点,她们可以用唯一id进行区分

3. diff算法执行时有3个维度，tree diff,component diff ,element diff
	1. tree diff

	
	react对树进行分层比较，属于同一层次的节点进行比较。当发现某一子节点不在了，直接删除改节点及其所有子节点，不会用于进一步的不叫
	
	注意：在开发组件时，保持稳定的 DOM 结构会有助于性能的提升。例如，可以通过 CSS 隐藏或显示节点，而不是真的移除或添加 DOM 节点。
	
	2. component diff

		 * 同一类型的组件则按照原策略继续比较virtual dom
		 * 不是同一类型的组件在react中会认为是dirty Component,从而替换整个组件下的所有节点
		 * 同一类型的组件如果用户准确知道virtual dom没有发生变化，可以通过react中的ShouldComponentUpdate中决定要不要进行diff


	3. element diff

	当节点处于同一层级时发生变化往往是数组发生变化，react diff提供3中节点操作，分别是插入、移动和删除
	
	* 插入 当新的dom树该层的集合中有，老的dom树集合中没有，则进行插入操作
	* 移动 当新的dom树集合中有，老的dom树该层的集合中也有，但是两个集合中的位置不一样则进行移动
	* 删除 当新的dom树集合中没有，老的dom树集合中有，则进行删除
	
4. 引用

	* [React 源码剖析系列 － 不可思议的 react dif](https://zhuanlan.zhihu.com/p/20346379?refer=purerender)

## 异步加载js脚本的方式
1. script标签中增加async或者defer属性，脚本会异步加载
2. async defer区别

	* defer脚本加载和页面渲染是同步进行，当脚本加载完后会等到页面渲染和其他脚本执行完成后，defer脚本才开始执行
	* async脚本加载也是和页面渲染同步执行，但是当async脚本加载完成后会立即执行，页面渲染暂停，直到脚本执行完后页面渲染才继续
	* 多个defer脚本按照引入的顺序执行。
	* 多个async脚本执行顺序不一定
![](https://s2.ax1x.com/2019/07/30/eGeZod.jpg)

## 数组扁平化
array提供了flat(depth)方法扁平数组，如果depth不传参默认是扁平一层数组，depth是提取嵌套数组结构的深度，默认值是1

测试数据
var arr = [1, [2, [3, 4, [5,6]]],'test',{a:1}];

实现代码

```
function flatDeep(arr,newArr = []) {
  arr.forEach(item => {
    if(Array.isArray(item)) {
      flat(item,newArr)
    } else {
      newArr.push(item)
    }
  });
  return newArr
}
```

```
function flatDeep(arr){
  return arr.reduce((acc,currentValue)=>{
    let concatArr = Array.isArray(currentValue)?flat2(currentValue):currentValue
    return acc.concat(concatArr)
  },[])
}
```

## 数组去重
1. set

```
function uniq(arr) {
  return Array.from(new Set(arr))
}
```
2. 遍历数组，添加到一个数组变量里面去，遍历的时候判断新的数组变量是否包含遍历那那项

## reverse 方法实现

```
function reverse(arr) {
  let newArr = []
  arr.forEach((item,index)=>{
    newArr[arr.length-1-index] = item;
  })
  return newArr
}
```
## js 数字分隔符，把一串数字表示成千位分隔形式
```
(12345678).toLocaleString() => "12,345,678"
```

```
// 价格千位符号分割
function segmentation(str) {
  if(typeof str === 'string'){
    const pattern = /\d{1,3}(?=(\d{3})+$)/g
    return str.replace(pattern,'$&,')
  } else {
    throw Error('请传字符串')
  }
}
```

## Promiseall的实现

```
var p1 = Promise.resolve(1),
p2 = Promise.reject(2),
p3 = Promise.resolve(3);
function promiseAll(promises) {
  return new Promise(function(resolve, reject) {
    let i= 0;
    let result = []
    promises.forEach(item => {
      item.then((res)=>{
        i++;
        result.push(res);
        if(i === promises.length){
          return resolve(result)
        }
      }).catch(e=>{
        return reject(e)
      })
    });
  })
}
promiseAll([p1,p2,p3]).then(res=>console.log(res)).catch(e=>console.log(e))
```

## 双向绑定

```
<body>
  <input type="text" id="a"/>
  <div id='b'>fwefwe</div>
</body>
<script>
  var obj = {};
  Object.defineProperty(obj,'hello',{
    set: function(newVal){
      console.log('newVal', newVal)
      document.getElementById('a').value = newVal
      document.getElementById('b').innerHTML = newVal
    },
  })
  document.getElementById('a').addEventListener('keyup',function(e){
    console.log(e)
    obj.hello = e.target.value
  })
</script>
```

[vue 双向数据绑定实现原理](https://juejin.im/entry/59116fa6a0bb9f0058aaaa4c)

## react hook
解决的痛点

1. 状态逻辑复用
2. 就是要解决 class 中生命周期函数经常包含不相关的逻辑，但又把相关逻辑分离到了几个不同方法中的问题。
3. 不用学习class，不用去了解this,入门难度降低

## 写一个方法，传0和10，返回一个1-10的数组，[0,1,2,3,4,5,6,7,8,9]

1. Array(10).fill(0).map((val,index)=>index)
2. [...Array(10).keys()]

## redux解决的痛点

对于复杂的单页面应用，状态（state）管理非常重要。state 可能包括：服务端的响应数据、本地对响应数据的缓存、本地创建的数据（比如，表单数据）以及一些 UI 的状态信息（比如，路由、选中的 tab、是否显示下拉列表、页码控制等等）。如果 state 变化不可预测，就会难于调试（state 不易重现，很难复现一些 bug）和不易于扩展（比如，优化更新渲染、服务端渲染、路由切换时获取数据等等）


## redux的核心思想（让状态可预测）
1. 单一数据源
2. 数据不可更改
3. reducer纯函数，（为了把action和state串起来，开发了一些函数，这就是reducer）,reducer只是一个接收state和action，并返回一个新的state的函数


## redux怎么改值

	redux的核心dispatch一个action，reducer接收到state和action，并返回一个新的state函数
## 闭包
 定义： 闭包是函数可以访问作用域之外的变量
 
 应用场景：
 1. 私有变量

## 前端规划
1. 知识

	1. js （每日一题，巩固自己基础知识）
	2. css （看css揭秘这本书）
	3. 安全 （《白帽子讲web安全》）
2. 技能

	1. node 
	2. ts
	3. D3
	4. webpack
	5. flutter
	6. react

## token和cookie的区别，用户验证区别
token是无状态的，cookie是有状态的
token优点：

1. 无状态，可扩展和解耦
2. 跨域和cors
3. 如果多台服务器，cookie要保持多台服务器生成的session Id一致，要保持session 共享

## vitual dom介绍一下

vitual dom本质是一个js对象，用对象来描述dom结构，至少包含节点类型，节点属性，子节点。它是在数据和真实dom建立了一层缓冲。对于开发者而言，数据变化就调用react的渲染方法，而react并不是得到一个新的dom进行替换，先生成一个vitualdom，再和上一次的virtual dom进行对比，找到改变的地方，再把变化的地方更新再真实的dom上，优化了性能

## localstorage 存数据什么类型
localstorage存的是字符串类型，boolean值也会被转换成字符串

## setTimeout 时间为什么不准确

  js是单线程，也就是说同一时间只能做一件事情。js的单线程特性就意味着多个任务需要排队，必须上一个任务结束后才能执行下一个任务。
  
  任务又分为同步任务和异步任务，同步任务进入主线程形成一个执行栈，异步任务的回调进入一个任务队列，排队被主线程进行调用
  
  js 运行机制
  
  1. 所有的同步任务在主线成上进行，形成一个执行栈 
  2. 异步任务形成一个任务队列 
  3. 当主线成的任务执行完成后，系统会读取‘任务队列’，那些对应的异步任务，结束等待状态，进入执行栈，开始执行
  
  setTimeout的时间不准确的原因是，当定时器的时间小于执行栈的时间，主线程的同步任务还来不及去调用这个异步任务，所以时间会产生误差
  
## null 和undefined区别
null: 此处不应该有值
应用场景：

1. 函数传参，表示函数的参数不是对象
2. 原形链的终点

undefined: 此处应该有值，但是还未定义
应用场景： 
1. 申明一个变量，未对这个变量赋值，这个变量就是undefined
2. 调用函数时，应该提供的参数没有提供，该参数为undefined
3. 对象没有赋值的属性，该属性的值为undefined
4. 函数没有返回值时，默认返回undefined
## 闭包是什么，闭包的应用
闭包：函数可以访问作用域之外的变量。
缺点：
1. 闭包使得
## react和vue的对比,区别


## 动画从左上角移动到右下角
## const 数组改变 为什么可以
## XSS 和 XSRF 防护 
## react 组件懒加载
## vue3.0为什么用proxy代替了objectdefine,vue生命周期
## 小程序渲染机制
## 判断数据类型
## 垂直居中
## 技术上遇到的难点
## react 组件设计
## react 懒加载
## webpack怎么打包
## flux的思想
