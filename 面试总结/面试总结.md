## 面试题
## new的实现

### new实现过程

1. 创建一个新的空对象
2. 给新对象构造原型链，内部属性[[Prototype]]属性赋值，指向构造函数的原型
3. 执行构造函数，构造函数的this指向新对象
4. 如果构造函数没有返回其他对象，那么返回这个this,即新对象，否则返回构造函数中的返回对象

### new实现代码

```
function _new () {
    let target = {};
    let {constructor,...args} = [...arguments];
    target.__proto__= constructor.prototype;
    let res = constructor.call(target,args)
    if((typeof res) === 'object' || (typeof res) === 'function'){
        return res
    } else {
        return target
    }
}
```


## promise
1. promise缺点

	* 无法取消promise，一旦新建它就会立即执行，无法中途取消。
	* 如果不设置毁掉函数，Promise内部跑出的错误，不会反应到外部
	* 处于pending状态时，无法得知目前进展到哪一个阶段，刚刚开始还是即将完成

2. 参考

	* [剖析Promise内部结构，一步一步实现一个完整的、能通过所有Test case的Promise类](https://github.com/xieranmaya/blog/issues/3)

## react diff
1. 优点： 作为virtualdom的加速器，优化页面渲染，提高性能

2. react diff 策略

	1. Dom节点跨层级移动特别少，可以忽略不计。
	2. 不同类的两个组件会生成相似的树形结构，相同类的组件树形结构相同
	3. 同一层级相同父元素的子节点用唯一id区分

3. diff算法执行时有3个维度，tree diff,component diff ,element diff
	1. tree diff

	
	react对树进行分层比较，属于同一层次的节点进行比较。
	
	注意：在开发组件时，保持稳定的 DOM 结构会有助于性能的提升。例如，可以通过 CSS 隐藏或显示节点，而不是真的移除或添加 DOM 节点。
	
	2. component diff

		 * 同一类型的组件则按照原策略继续比较virtual dom
		 * 不是同一类型的组件在react中会认为是dirty Component,从而替换整个组件下的所有节点
		 * 同一类型的组件如果用户准确知道virtual dom没有发生变化，可以通过react中的ShouldComponentUpdate中决定要不要进行diff


	3. element diff

	当节点处于同一层级时发生变化往往是数组发生变化，react diff提供3中节点操作，分别是插入、移动和删除
	
	* 插入 当新的dom树该层的集合中有，老的dom树集合中没有，则进行插入操作
	* 移动 当新的dom树集合中有，老的dom树该层的集合中也有，但是两个集合中的位置不一样则进行移动
	* 删除 当新的dom树集合中没有，老的dom树集合中有，则进行删除
	
4. 引用

	* [React 源码剖析系列 － 不可思议的 react dif](https://zhuanlan.zhihu.com/p/20346379?refer=purerender)

## 异步加载js脚本的方式
1. script标签中增加async或者defer属性，脚本会异步加载
2. async defer区别

	* defer脚本加载和页面渲染是同步进行，当脚本加载完后会等到页面渲染和其他脚本执行完成后，defer脚本才开始执行
	* async脚本加载也是和页面渲染同步执行，但是当async脚本加载完成后会立即执行，页面渲染暂停，直到脚本执行完后页面渲染才继续
	* 多个defer脚本按照引入的顺序执行。
	* 多个async脚本执行顺序不一定
![](https://s2.ax1x.com/2019/07/30/eGeZod.jpg)

## 一行3列布局
